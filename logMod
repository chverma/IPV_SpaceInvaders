[1mdiff --git a/Initialization.html b/Initialization.html	<CHARACTER>                         <!-- Now is used the same character to all players -->		<NAME>PLAYER2</NAME>		<EXPLOSION>500</EXPLOSION>	    <!-- Miliseconds this explosion lasts -->		<HEALTH>20</HEALTH>        <LIVES>3</LIVES>		<MESH>player2.3ds</MESH>        <TEXTURE2D>player2.tga</TEXTURE2D>        <ACCELERATION>0.0001</ACCELERATION>        <SPEED> 		    <X>0.01</X>	<!--in units per milisecond-->		    <Y>0.0</Y>		    <Z>0.0</Z>	    </SPEED>	</CHARACTER>[1mdiff --git a/Levels/Level_0.html b/Levels/Level_0.html	<CHARACTER>        <NAME>PLAYER2</NAME>        <HEALTH>20</HEALTH>        <EXPLOSION>500</EXPLOSION>        <LIVES>3</LIVES>        <MESH>player2.3ds</MESH>        <TEXTURE2D>player2.tga</TEXTURE2D>    </CHARACTER>[1mdiff --git a/images/player2.bmp b/images/player2.bmp[1mdiff --git a/images/player2.tga b/images/player2.tga[1mdiff --git a/images/player3d2.bmp b/images/player3d2.bmp[1mdiff --git a/images/player3d2.tga b/images/player3d2.tga[1mdiff --git a/include/GameCharacters.h b/include/GameCharacters.h 	CHARS_MISSIL,				///<A common shooting from any ship, supplyship or player 	CHARS_NAVY,					///<Holds all the supplyships and all types of ships 	CHARS_PLAYER,				///<The player	CHARS_PLAYER2,				///<The player2 	CHARS_PLAYER_SHOOT,			///<Player shoots 	CHARS_REACTOR,				///<Extra power engines and shooters for the player. Obtained after the corresponding bonus has been won 	CHARS_SHIP,					///<Alien normal space ships[1mdiff --git a/include/Global.h b/include/Global.h #include "QuadtreeRoot.h" #include <Application.h> #include "Player.h"#include "Player2.h" #include "TextoGL.h" #include "fpsGL.h" #include <SIMessage.h>[36m@@ -136,7 +135,6 @@[m [mextern CBonus			defaultBonus; extern CBrick			defaultBrick; extern CBunker			defaultBunker; extern CPlayer			defaultPlayer;extern CPlayer2			defaultPlayer2; extern CShip			defaultShip; extern CSupplyShip		defaultSShip; extern CCircleShip		defaultCShip;[36m@@ -147,7 +145,6 @@[m [mextern CLog				Log;				///<For logging performance, tracing,...  ///Amount of players simultaneously available when playing extern CPlayer			Player[CP_MAX_PLAYERS];	// PLAYERS AVAILABLEextern CPlayer2			Player2[CP_MAX_PLAYERS];	// PLAYERS AVAILABLE extern int				CurrentPlayer;  extern float			UGKALG_NullMatrix[16];[1mdiff --git a/include/LevelParser.h b/include/LevelParser.h 	TEXTURE3D_CHARACTER_L, 	TIMECIRCLESHIP_L, 	TIMEPLAYER_L,	TIMEPLAYER2_L, 	TIMERENDER_L, 	TIMESHIP_L, 	TIMESHOOTS_L,[1mdiff --git a/include/Player2.h b/include/Player2.h/**	Definition of the class Player	Class prefix CP_	@author Ramon Molla	@version 2011-09-11*/#ifndef CP_CLASS_PLAYER2#define CP_CLASS_PLAYER2#include "Laser.h"#include "Shoot.h"#include "Reactor.h"#include <HRTimer.h>#include <ExecutionMode.h>#define CP_MAX_HEALTH2			 20	///<Maximun amount of health of the player by default#define CP_MAX_MAX_HIT_DUR2		500	///<Maximun amount of time when the player is hit#define CP_INFINITE_LIVES2		 -1 ///<Constant value for ethernal life#define CP_DEFAULT_LIVES2		  3 ///<If not specified, by default, ther are three lives#define CP_MAX_PLAYERS2			  1 ///<By default, if not specified, there may play at the same time only 4 players#define CP_NO_PLAYER2		 -1	//#define CP_DEFAULT_PLAYER2		  0	//#define CP_MAX_SPEED2			0.01f	//Maximun X speed in units/ms#define CP_MAX_ACCEL2			0.01f	//Maximun X acceleration in units/ms#define CP_2D_SIZE_X2				0.6f	//Maximun X acceleration in units/ms#define CP_2D_SIZE_Y2				0.4f	//Maximun X acceleration in units/ms#define CP_3D_SIZE_X2				0.8f	//Maximun X acceleration in units/ms#define CP_3D_SIZE_Y2				1.0f	//Maximun X acceleration in units/ms#define CP_LASER_REL_POS2		0.05f	///<Left or right laser relative position respect to the palyer on the X axis//Shooting#define CP_SHOOT2D_SPEED2		0.008f#define CP_SHOOT3D_SPEED2		0.017ftypedef enum {	CP_LEFT_LASER2,					///<Code for left laser	CP_RIGHT_LASER2,					///<Code for right laser	CP_MAX_LASERS2					///<Amount of extra lasers the player has} CP_PLAYER_LASER2;typedef enum {	CP_UNBORN2=0,	///<For management purpouses only	CP_BORN2,		///<The character is just born but it is not still operative (living)	CP_LIVING2,		///<Everything this character may do while it is alive 	CP_DYING2,		///<The character has been touched so many times that its life has gone negative. So it has to burst before being died. Starts an explosion and dies	CP_DEAD2,		///<The character is no operative. Reached after dying	CP_MAXSTATE2		///<For management purpouses only} CP_PLAYER_STATE2;typedef enum {	CP_MOVE_LEFT2,			///<The player wants to move to the left	CP_MOVE_RIGHT2,			///<The player wants to move to the right	CP_SHOOT2,				///<The player wants to fire a shoot	CP_MAX_PLAYER_EVENTS2	// Only for management purpouses} CP_PLAYER_EVENTS2;class CPlayer2: public CCharacter{	//Attributespublic:	unsigned short int	Lives;		///<Amount of lives a player can lose before finishing the game	float		yi;			// le vaisseau est secou? (passage ? game 3D)	float		yi_speed;	// le vaisseau est secou? (vitesse)	float		yi_cos;		// le vaisseau est secou? (variable de cosinus)	float		zi;			// le vaisseau 'flotte' (coord z, pour mode 3D)	float		zi_speed;	// le vaisseau 'flotte' (vitesse)	float		Scrolling;	// Speed used in the scrolling, Control to rotate the Player	CExplosion	Explosion;	///<When the ships loses its life, it burst. This is the particle system to perform the explosion	//Shooting	CSH_SHOOT_TYPE	ShootType;	///<TYPE of shooting power in a given moment. It depends on the bonus got during the playing	float			ShootSpeed;	///<Initial speed of the current shoot	CP_PLAYER_STATE State;	//RT-DESK	double timeRTdeskMsg;						//Tiempo Mensaje RTDESK	RTDESK_CMsg *msg;							//RTDESK Message Time	RTDESK_TIME TicksToUpdatePlayer;	cHRTimer UpdatePlayerTimer;	double msUpdPlayer;	//Weapons	CLaser		Laser	[CP_MAX_LASERS];	///<Extra lasers a player can have in a given moment	CReactor	Reactor;					///<Reactors the player's ship have to perform the movement	//Methods	bool Init ();	//Used when all the values are initialized by default					//when reading the global initialization game file					//Returns true if the initialization of the attirbute has been correctly done	CPlayer2();		//Constructor	///Character AI virtual methods rewritten	void AI_Init	(void);	///<Default Artificial Intelligence character initialization	void AI_Dye		(void);	void AI_Explode (void);	void ActivateLaser	(CP_PLAYER_LASER Laser);	void ActivateReactor(void);	//Physics	void Collided (CCharacter *CollidedChar);	///Shows the player on the screen	void Render				(void);	///Change the way the player is going to be rendered on the screen	void ChangeRenderMode	(CHAR_RENDER_MODE);	void RenderExplosion	(void);	void DiscreteUpdate		(void);	void Update				(void);	//Transformation methods	void MoveTo		(float x, float y, float z);	///<Moves to the absolute coordinate x,y,z	void MoveTo		(Vector &Move);					///<Moving to an absolute position. It does not matter where the character is	void MoveRelTo	(float x, float y, float z);	///<Moves x,y,z units from the to the current position	void MoveRelTo	(Vector &Move);					///<Moving relative to the character current Position	//User interaction. One method for every player command sent to the player's avatar	void ManageEvent(unsigned int);	///<Virtual method for managing events	void UserRight	();	void UserLeft	();	void UserShoot	();	void DiscreteUserShoot	();		void ReceiveMessage(RTDESK_CMsg *pMsg);	};#endif[1mdiff --git a/include/SIGame.h b/include/SIGame.h #define CSIG_PG_SHIPS_CEILING	10.0f  #define CSIG_PLAYER_Y_POSITION			-6.5f#define CSIG_PLAYER2_Y_POSITION			-6.0f #define CSIG_NAVY_INITIAL_Y_POSITION	 2.0f  #define CSIG_INTERMISSION_TEXT_BLINKS 3[36m@@ -53,7 +52,7 @@ #define CSIG_INITIALIZATION_LOG_FILE	".\\InitializationLog.txt" //ANA #define CSIG_LANGUAGE_LOG_FILE	".\\LANInitializationLog.txt"#define CSIG_GAME_ULEVEL_FILE			".\\Levels\\"#define CSIG_GAME_ULEVEL_FILE			".\\Levels\\UserLevels\\"  #define CSIG_MIN_UPDATETIME_OBJECTS	40	//ms. None of the objects should update over this period of time. [36m@@ -147,7 +146,6 @@[m [mclass CSIGame: public CGame 	RTDESK_TIME elapTimeSShipsUpd; 	RTDESK_TIME elapTimeCShipsUpd; 	RTDESK_TIME elapTimePlayerUpd;	RTDESK_TIME elapTimePlayer2Upd;  	RTDESK_TIME lastTimeRnd; 	RTDESK_TIME lastTimeUpd;[36m@@ -155,7 +153,6 @@[m [mclass CSIGame: public CGame 	RTDESK_TIME lastTimeSShipsUpd; 	RTDESK_TIME lastTimeCShipsUpd; 	RTDESK_TIME lastTimePlayerUpd;	RTDESK_TIME lastTimePlayer2Upd;  	void InitGraphics(); [36m@@ -228,7 +225,6 @@[m [mpublic: 	double ShipTemp; 	double NavyShipsTemp; 	double PlayerTemp;	double Player2Temp; 	double ShootsTemp; 	double RenderTemp; 	double UpdateTemp;  [1mdiff --git a/include/SIKeyboard.h b/include/SIKeyboard.h[36m@@ -77,9 +77,6 @@[m [mtypedef enum { 	CSIK_PLAYER_PAUSE, 	CSIK_HELP, 	CSIK_PLAYER2_MOVE_RIGHT,	///<Player2 ship is move rightwards	CSIK_PLAYER2_MOVE_LEFT,	///<Player2 ship is move leftwards	CSIK_PLAYER2_SHOOT,		///<Laser fire 	CSIK_MAX_KBD_ACTION			///<For accounting purpouses only } CSIK_KEYBOARD_ACTION; [1mdiff --git a/models/player2.3ds b/models/player2.3ds[1mdiff --git a/src/GUI.cpp b/src/GUI.cpp[36m@@ -568,43 +568,41 @@[m [mvoid CGUI::display_score_hiscore_lives() void CGUI::display_below_lives() { 	//glEnable(GL_BLEND);	//<This check must be removed when Player[CurrentPlayer].Lives doesn't reach 65555.	if(Player[CurrentPlayer].Lives>0 && Player[CurrentPlayer].Lives<4){		glColor4f (1.0f, 1.0f, 1.0f, 1.0f);		// la figura 0, 1, 2 ou 3 		TexturesManager.Textures[CTM_NUMBER0 + Player[CurrentPlayer].Lives]->SetTexture();		glBegin (GL_QUADS);			glTexCoord2f (0,1);	glVertex2f (CSIG_PG_LEFT  - .4f, -6.9f +.25f);			glTexCoord2f (0,0);	glVertex2f (CSIG_PG_LEFT  - .4f, -6.9f -.25f);			glTexCoord2f (1,0);	glVertex2f (CSIG_PG_LEFT  + .4f, -6.9f -.25f);			glTexCoord2f (1,1);	glVertex2f (CSIG_PG_LEFT  + .4f, -6.9f +.25f);		glEnd ();	[glColor4f (1.0f, 1.0f, 1.0f, 1.0f);	[// la figura 0, 1, 2 ou 3[m[41m 	[TexturesManager.Textures[CTM_NUMBER0 + Player[CurrentPlayer].Lives]->SetTexture();	[glBegin (GL_QUADS);		[glTexCoord2f (0,1);	glVertex2f (CSIG_PG_LEFT  - .4f, -6.9f +.25f);		[glTexCoord2f (0,0);	glVertex2f (CSIG_PG_LEFT  - .4f, -6.9f -.25f);		[glTexCoord2f (1,0);	glVertex2f (CSIG_PG_LEFT  + .4f, -6.9f -.25f);		[glTexCoord2f (1,1);	glVertex2f (CSIG_PG_LEFT  + .4f, -6.9f +.25f);	[glEnd (); 		// ALPHA TEST + BLEND		glAlphaFunc(GL_GREATER, 0.3f);								// for TGA alpha test		glEnable(GL_ALPHA_TEST);									// for TGA alpha test		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);			// for anti-aliasing	[// ALPHA TEST + BLEND	[glAlphaFunc(GL_GREATER, 0.3f);								// for TGA alpha test	[glEnable(GL_ALPHA_TEST);									// for TGA alpha test	[glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);			// for anti-aliasing 		// los buques en el verde abajo a la derecha		for (int k=1; k <= Player[CurrentPlayer].Lives; k++)		{			glColor4f (1.0f, 1.0f, 1.0f, 1.0f);			if (CHAR_2D == Game.RenderMode)				TexturesManager.Textures[Player[CurrentPlayer].IndTexture2D]->SetTexture();			else				TexturesManager.Textures[CTM_PLAYER3D]->SetTexture();	[// los buques en el verde abajo a la derecha	[for (int k=1; k <= Player[CurrentPlayer].Lives; k++)	[{		[glColor4f (1.0f, 1.0f, 1.0f, 1.0f);		[if (CHAR_2D == Game.RenderMode)			[TexturesManager.Textures[Player[CurrentPlayer].IndTexture2D]->SetTexture();		[else			[TexturesManager.Textures[CTM_PLAYER3D]->SetTexture(); 			glBegin (GL_QUADS);				glTexCoord2f (0,1);	glVertex2f (CSIG_PG_LEFT + k/1.3f - .3f, -6.9f +.25f);				glTexCoord2f (0,0);	glVertex2f (CSIG_PG_LEFT + k/1.3f - .3f, -6.9f -.25f);				glTexCoord2f (1,0);	glVertex2f (CSIG_PG_LEFT + k/1.3f + .3f, -6.9f -.25f);				glTexCoord2f (1,1);	glVertex2f (CSIG_PG_LEFT + k/1.3f + .3f, -6.9f +.25f);			glEnd ();				}		// BACK TO NON ALPHA TEST + PREVIOUS BLEND		glDisable(GL_ALPHA_TEST);		//glDisable(GL_BLEND);		[glBegin (GL_QUADS);			[glTexCoord2f (0,1);	glVertex2f (CSIG_PG_LEFT + k/1.3f - .3f, -6.9f +.25f);			[glTexCoord2f (0,0);	glVertex2f (CSIG_PG_LEFT + k/1.3f - .3f, -6.9f -.25f);			[glTexCoord2f (1,0);	glVertex2f (CSIG_PG_LEFT + k/1.3f + .3f, -6.9f -.25f);			[glTexCoord2f (1,1);	glVertex2f (CSIG_PG_LEFT + k/1.3f + .3f, -6.9f +.25f);		[glEnd ();[m[41m		 	}	[// BACK TO NON ALPHA TEST + PREVIOUS BLEND	[glDisable(GL_ALPHA_TEST);	[//glDisable(GL_BLEND); }  /**   [36m@@ -1344,7 +1342,7 @@[m [mvoid CGUI::display_text_frames()     * Also being showing the life disminusicion */ void CGUI::display_Health(){ //Afegir vida player 2 { 	boometer->Render(Player[CurrentPlayer].Health/Player[CurrentPlayer].MaxHealth); } [1mdiff --git a/src/GameCharacters.cpp b/src/GameCharacters.cpp[36m@@ -33,7 +33,6 @@[m [mchar CHARS_Tags[CHARS_MAX_CHARTYPE][GCHAR_TAG_MAX_LONG ] = 	CHARS_MISSIL,				///<A common shooting from any ship, supplyship or player 	CHARS_NAVY,					///<Holds all the supplyships and all types of ships 	CHARS_PLAYER,				///<The player	CHARS_PLAYER2,				///<The player2 	CHARS_PLAYER_SHOOT,			///<Player shoots 	CHARS_REACTOR,				///<Extra power engines and shooters for the player. Obtained after the corresponding bonus has been won 	CHARS_SHIP,					///<Alien normal space ships[36m@@ -55,7 +54,6 @@[m [mchar CHARS_Tags[CHARS_MAX_CHARTYPE][GCHAR_TAG_MAX_LONG ] = 	"MISSIL", 	"NAVY", 	"PLAYER",	"PLAYER2", 	"PLAYER_SHOOT", 	"REACTOR", 	"SHIP",[1mdiff --git a/src/Global.cpp b/src/Global.cpp ///Amount of players simultaneously available when playing CPlayer		 Player[CP_MAX_PLAYERS];	// PLAYERS AVAILABLECPlayer2	 Player2[CP_MAX_PLAYERS];	// PLAYERS AVAILABLE int CurrentPlayer	= CP_NO_PLAYER;		///<Initially, the player by default is the one before the first one  [1mdiff --git a/src/InitializationParser.cpp b/src/InitializationParser.cpp[36m@@ -107,7 +107,6 @@[m [mCBonus			defaultBonus; CBunker			defaultBunker; CBrick			defaultBrick; CPlayer			defaultPlayer;CPlayer2		defaultPlayer2; CShip			defaultShip; CSupplyShip		defaultSShip; CCircleShip		defaultCShip;[36m@@ -529,9 +528,6 @@[m [mvoid CInitializationReader::EndTag(CLiteHTMLTag *pTag, DWORD dwAppData, bool &bA 				case CHARS_PLAYER: 					defaultPlayer.IndAnimation2D = AnimationsManager.Animations.size()-1; 						break;				case CHARS_PLAYER2:					defaultPlayer2.IndAnimation2D = AnimationsManager.Animations.size()-1;						break; 				case CHARS_SHIP: 					defaultShip.IndAnimation2D = AnimationsManager.Animations.size()-1; 						break;[36m@@ -542,10 +538,8 @@[m [mvoid CInitializationReader::EndTag(CLiteHTMLTag *pTag, DWORD dwAppData, bool &bA 					defaultCShip.IndAnimation2D = AnimationsManager.Animations.size()-1; 					break; 				case CHARS_LASER:					for(int i=0;i<CP_MAX_LASERS;i++){					[for(int i=0;i<CP_MAX_LASERS;i++) 						defaultPlayer.Laser[i].IndAnimation2D = AnimationsManager.Animations.size()-1;						defaultPlayer2.Laser[i].IndAnimation2D = AnimationsManager.Animations.size()-1;					} 						break; 				case CHARS_SPHERE_OGIVE: 					Background.IndAnimation2D = AnimationsManager.Animations.size()-1;[36m@@ -640,9 +634,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 		case CHARS_PLAYER: 			defaultPlayer.Acceleration.v[XDIM] = atof (rText); 			break;		case CHARS_PLAYER2:			defaultPlayer2.Acceleration.v[XDIM] = atof (rText);			break; 		case CHARS_SHIP: 			defaultShip.Acceleration.v[XDIM] = atof (rText); 			break;[36m@@ -674,20 +665,11 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 				defaultPlayer.Laser[CP_LEFT_LASER].Explosion.SubType = CE_LASER_EXPLOSION; 				defaultPlayer.Laser[CP_RIGHT_LASER].Hit_duration	= atof (rText); 				defaultPlayer.Laser[CP_RIGHT_LASER].Explosion.SubType = CE_LASER_EXPLOSION;				defaultPlayer2.Laser[CP_LEFT_LASER].Hit_duration	= atof (rText);				defaultPlayer2.Laser[CP_LEFT_LASER].Explosion.SubType = CE_LASER_EXPLOSION;				defaultPlayer2.Laser[CP_RIGHT_LASER].Hit_duration	= atof (rText);				defaultPlayer2.Laser[CP_RIGHT_LASER].Explosion.SubType = CE_LASER_EXPLOSION; 				 break; 			 case CHARS_PLAYER: 				 defaultPlayer.Hit_duration	= atof (rText); 				 defaultPlayer.Explosion.SubType = CE_PLAYER_EXPLOSION; 				 break;			case CHARS_PLAYER2:				 defaultPlayer2.Hit_duration	= atof (rText);				 defaultPlayer2.Explosion.SubType = CE_PLAYER_EXPLOSION;				 break; 			case CHARS_SHIP: 				 defaultShip.Hit_duration	= atof (rText); 				 defaultShip.Explosion.SubType = CE_SHIP_EXPLOSION;[36m@@ -725,15 +707,10 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 			case CHARS_LASER: 				defaultPlayer.Laser[CP_LEFT_LASER].Health	= atof (rText); 				defaultPlayer.Laser[CP_RIGHT_LASER].Health	= atof (rText);				defaultPlayer2.Laser[CP_LEFT_LASER].Health	= atof (rText);				defaultPlayer2.Laser[CP_RIGHT_LASER].Health	= atof (rText); 				 break; 			 case CHARS_PLAYER: 				 defaultPlayer.Health	= atof (rText); 				 break;			 case CHARS_PLAYER2:				 defaultPlayer2.Health	= atof (rText);				 break; 			case CHARS_SHIP: 				 defaultShip.Health	= atof (rText); 				 break;[36m@@ -746,10 +723,8 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 					strcpy(Application.LanguageFolder, rText); 		break; 	case LIVES:		//Amount of ships the Player has still before finishing the game			if(CP_INFINITE_LIVES == atoi(rText)){			[if(CP_INFINITE_LIVES == atoi(rText)) 				defaultPlayer.Lives = CP_INFINITE_LIVES;				defaultPlayer2.Lives = CP_INFINITE_LIVES;			} 			else if (0 > atoi(rText)) 				{ 					strcpy(msj, CIP_ParserMsgs[CIP_MIN_LIVES_NOT_DEF]);[36m@@ -760,12 +735,9 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 					strcat(msj, CIP_ParserMsgs[CIP_MINIMUM]); 					ErrorParser (msj); 					defaultPlayer.Lives = 1;					defaultPlayer2.Lives = 1; 				}				else if (SHRT_MAX > atoi(rText)){					defaultPlayer.Lives = atoi(rText);					defaultPlayer2.Lives = atoi(rText);				} else					[else if (SHRT_MAX > atoi(rText)) defaultPlayer.Lives = atoi(rText);					[ else[m[ 					 { 						strcpy(msj, CIP_ParserMsgs[CIP_MAX_LIVES_NOT_DEF]); 						strcat(msj, rText);[36m@@ -775,7 +747,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 						strcat(msj, CIP_ParserMsgs[CIP_MAXIMUM]); 						ErrorParser (msj); 						defaultPlayer.Lives = SHRT_MAX;						defaultPlayer2.Lives = SHRT_MAX; 					} 		break; 	case MESH_CHARACTER:[36m@@ -798,17 +769,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 					strcpy(defaultPlayer.MeshName, defaultPlayer.Mesh->GetFileName()); 				} 				 break;			case CHARS_PLAYER2:				if (MeshSemaphore[CHARS_PLAYER2])				{					MeshSemaphore[CHARS_PLAYER2] = false;					strcpy(msj, rText);					MeshesManager.AddModel(msj);					defaultPlayer2.IndMesh = MeshesManager.Meshes.size()-1;					defaultPlayer2.Mesh = MeshesManager.Meshes[defaultPlayer2.IndMesh];					strcpy(defaultPlayer2.MeshName, defaultPlayer2.Mesh->GetFileName());				}				 break; 			case CHARS_SHIP: 				if (MeshSemaphore[CHARS_SHIP]) 				{[36m@@ -853,10 +813,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 						defaultPlayer.Laser[i].IndMesh = MeshesManager.Meshes.size()-1; 						defaultPlayer.Laser[i].Mesh = MeshesManager.Meshes[defaultPlayer.Laser[i].IndMesh]; 						strcpy(defaultPlayer.Laser[i].MeshName, defaultPlayer.Laser[i].Mesh->GetFileName());						defaultPlayer2.Laser[i].IndMesh = MeshesManager.Meshes.size()-1;						defaultPlayer2.Laser[i].Mesh = MeshesManager.Meshes[defaultPlayer2.Laser[i].IndMesh];						strcpy(defaultPlayer2.Laser[i].MeshName, defaultPlayer2.Laser[i].Mesh->GetFileName()); 					} 				} 				 break;[36m@@ -897,10 +853,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 				//Reset all the values by default in case the file does not cover every object aspect 				defaultPlayer.Init(); 				break;			case CHARS_PLAYER2:				//Reset all the values by default in case the file does not cover every object aspect				defaultPlayer2.Init();				break; 			case CHARS_SHIP: 				//Reset all the values by default in case the file does not cover every object aspect 				defaultShip.Init();[36m@@ -913,7 +865,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 				//Reset all the values by default in case the file does not cover every object aspect 				for(i=0;i<CP_MAX_LASERS;i++){ 					defaultPlayer.Laser[i].Init();					defaultPlayer2.Laser[i].Init(); 				} 				break; 			case CHARS_CIRCLESHIP:[36m@@ -939,7 +890,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 			case CHARS_BRICK: 			case CHARS_BUNKER: 			case CHARS_PLAYER:			case CHARS_PLAYER2: 			case CHARS_SHIP: 			case CHARS_SUPPLYSHIP: 			case CHARS_CIRCLESHIP:[36m@@ -957,7 +907,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 			case CHARS_BRICK: 			case CHARS_BUNKER: 			case CHARS_PLAYER:			case CHARS_PLAYER2: 			case CHARS_SHIP: 			case CHARS_SUPPLYSHIP: 			case CHARS_CIRCLESHIP:[36m@@ -997,9 +946,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 		case CHARS_PLAYER: 			defaultPlayer.Speed.v[XDIM] = atof (rText); 			break;		case CHARS_PLAYER2:			defaultPlayer2.Speed.v[XDIM] = atof (rText);			break; 		case CHARS_SHIP: 			defaultShip.Speed.v[XDIM] = atof (rText); 			break;[36m@@ -1028,9 +974,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 		case CHARS_PLAYER: 			defaultPlayer.Speed.v[YDIM] = atof (rText); 			break;		case CHARS_PLAYER2:			defaultPlayer2.Speed.v[YDIM] = atof (rText);			break; 		case CHARS_SHIP: 			defaultShip.Speed.v[YDIM] = atof (rText); 			break;[36m@@ -1058,9 +1001,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 		case CHARS_PLAYER: 			defaultPlayer.Speed.v[ZDIM] = atof (rText); 			break;		case CHARS_PLAYER2:			defaultPlayer2.Speed.v[ZDIM] = atof (rText);			break; 		case CHARS_SHIP: 			defaultShip.Speed.v[ZDIM] = atof (rText); 			break;[36m@@ -1100,13 +1040,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 					defaultPlayer.IndTexture2D = TexturesManager.Textures.size()-1; 				} 				 break;			case CHARS_PLAYER2:				strcpy(msj, rText);				for(i=0;i<CP_MAX_PLAYERS;i++){					TexturesManager.CreateTexture(msj);					defaultPlayer2.IndTexture2D = TexturesManager.Textures.size()-1;				}				 break; 			case CHARS_SHIP: 				strcpy(msj, rText); 				TexturesManager.CreateTexture(msj);[36m@@ -1141,11 +1074,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 				TexturesManager.CreateTexture(msj); 				AnimationsManager.Animations.back()->AddPhotogram(TexturesManager.Textures.back()); 				 break;			case CHARS_PLAYER2:				strcpy(msj, rText);				TexturesManager.CreateTexture(msj);				AnimationsManager.Animations.back()->AddPhotogram(TexturesManager.Textures.back());				 break; 			case CHARS_SHIP: 				strcpy(msj, rText); 				TexturesManager.CreateTexture(msj);[36m@@ -1179,11 +1107,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 				TexturesManager.CreateTexture(msj); 				defaultPlayer.IndTexture3D = TexturesManager.Textures.size()-1; 				 break;			case CHARS_PLAYER2:				strcpy(msj, rText);				TexturesManager.CreateTexture(msj);				defaultPlayer2.IndTexture3D = TexturesManager.Textures.size()-1;				 break; 			case CHARS_SHIP: 				strcpy(msj, rText); 				TexturesManager.CreateTexture(msj);[36m@@ -1229,7 +1152,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 			case CHARS_BRICK: 			case CHARS_BUNKER: 			case CHARS_PLAYER:			case CHARS_PLAYER2: 			case CHARS_SHIP: 			case CHARS_SUPPLYSHIP: 			case CHARS_CIRCLESHIP:[1mdiff --git a/src/LevelParser.cpp b/src/LevelParser.cpp[36m@@ -95,7 +95,6 @@[m [mchar CLeP_Tags[MAXTAGS_L][CLeP_TAG_MAX_LONG] = 	"TEXTURE3D_CHARACTER", 	"TIMECIRCLESHIP", 	"TIMEPLAYER",	"TIMEPLAYER2", 	"TIMERENDER", 	"TIMESHIP", 	"TIMESHOOTS",[36m@@ -167,7 +166,6 @@[m [mextern CBonus			defaultBonus; extern CBunker			defaultBunker; extern CBrick			defaultBrick; extern CPlayer			defaultPlayer;extern CPlayer2			defaultPlayer2; extern CShip			defaultShip; extern CSupplyShip		defaultSShip; [36m@@ -190,8 +188,6 @@[m [mvoid CLevelReader::TagError(char *Text)  CLevelReader::CLevelReader() {	Version	= NULL;	Title	= NULL; 	strcpy(Type,"Level");	//Type of parser 	ResetState(); 	StateStack.push(NIL_L);[36m@@ -325,20 +321,18 @@[m [mswitch (Name[0]) 							if (strcmp(Name, CLeP_Tags[TYPE_L])) 								if (strcmp(Name, CLeP_Tags[TIMECIRCLESHIP_L])) 									if (strcmp(Name, CLeP_Tags[TIMEPLAYER_L]))										if (strcmp(Name, CLeP_Tags[TIMEPLAYER2_L]))											if (strcmp(Name, CLeP_Tags[TIMERENDER_L]))												if (strcmp(Name, CLeP_Tags[TIMESHIP_L]))													if (strcmp(Name, CLeP_Tags[TIMESHOOTS_L]))														if (strcmp(Name, CLeP_Tags[TIMESUPPLYSHIP_L]))															if (strcmp(Name, CLeP_Tags[TIMEBONUS_L]))																if (strcmp(Name, CLeP_Tags[TIMEUPDATE_L])) return UNKNOWN_L;																else	return TIMEBONUS_L;															else	return TIMEUPDATE_L;														else		return TIMESUPPLYSHIP_L;													else			return TIMESHOOTS_L;												else				return TIMESHIP_L;											else					return TIMERENDER_L;										else						return TIMEPLAYER2_L;										[if (strcmp(Name, CLeP_Tags[TIMERENDER_L]))											[if (strcmp(Name, CLeP_Tags[TIMESHIP_L]))												[if (strcmp(Name, CLeP_Tags[TIMESHOOTS_L]))													[if (strcmp(Name, CLeP_Tags[TIMESUPPLYSHIP_L]))														[if (strcmp(Name, CLeP_Tags[TIMEBONUS_L]))															[if (strcmp(Name, CLeP_Tags[TIMEUPDATE_L])) return UNKNOWN_L;															[else	return TIMEBONUS_L;														[else	return TIMEUPDATE_L;													[else		return TIMESUPPLYSHIP_L;												[else			return TIMESHOOTS_L;											[else				return TIMESHIP_L;										[else					return TIMERENDER_L; 									else						return TIMEPLAYER_L; 								else							return TIMECIRCLESHIP_L; 							else								return TYPE_L;[36m@@ -560,7 +554,6 @@[m [mvoid CLevelReader::StartTag(CLiteHTMLTag *pTag, DWORD dwAppData, bool &bAbort) 					case TIMEBONUS_L: 					case TIMESUPPLYSHIP_L: 					case TIMEPLAYER_L:					case TIMEPLAYER2_L: 					case TIMERENDER_L: 					case TIMEUPDATE_L: 					case SHIPSAMOUNT_L:[36m@@ -816,7 +809,6 @@[m [mvoid CLevelReader::EndTag(CLiteHTMLTag *pTag, DWORD dwAppData, bool &bAbort) 	case TIMEBONUS_L: 	case TIMESUPPLYSHIP_L: 	case TIMEPLAYER_L:	case TIMEPLAYER2_L: 	case TIMERENDER_L: 	case TIMEUPDATE_L: 	 case TITLE_L:		[36m@@ -844,12 +836,6 @@[m [mvoid CLevelReader::EndTag(CLiteHTMLTag *pTag, DWORD dwAppData, bool &bAbort) 						else 							Player[CurrentPlayer].IndAnimation2D = AnimationsManager.SearchIndOfName(msjAux); 							break;					case CHARS_PLAYER2:						if(!AnimationExist)							Player2[CurrentPlayer].IndAnimation2D = AnimationsManager.Animations.size()-1;						else							Player2[CurrentPlayer].IndAnimation2D = AnimationsManager.SearchIndOfName(msjAux);							break; 					case CHARS_SHIP: 						//ACHTUNG: PENDIENTE DE CREAR SHIPS DESDE MATRIZ DE LEVEL 						[36m@@ -872,15 +858,11 @@[m [mvoid CLevelReader::EndTag(CLiteHTMLTag *pTag, DWORD dwAppData, bool &bAbort) 						 					case CHARS_LASER: 						if(!AnimationExist)							for(int i=0;i<CP_MAX_LASERS;i++){							[for(int i=0;i<CP_MAX_LASERS;i++) 								Player[CurrentPlayer].Laser[i].IndAnimation2D = AnimationsManager.Animations.size()-1;								Player2[CurrentPlayer].Laser[i].IndAnimation2D = AnimationsManager.Animations.size()-1;							} 						else							for(int i=0;i<CP_MAX_LASERS;i++){							[for(int i=0;i<CP_MAX_LASERS;i++) 								Player[CurrentPlayer].Laser[i].IndAnimation2D = AnimationsManager.SearchIndOfName(msjAux);								Player2[CurrentPlayer].Laser[i].IndAnimation2D = AnimationsManager.SearchIndOfName(msjAux);							} 							break; 					case CHARS_SPHERE_OGIVE: 						if(!AnimationExist)[36m@@ -1000,7 +982,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 	{ 	case ACCELERATION_L: 		Player[CurrentPlayer].Acceleration.v[XDIM] = atof (rText);		Player2[CurrentPlayer].Acceleration.v[XDIM] = atof (rText); 		break; 	case BOUNCE_L: 		if (atoi(rText))[36m@@ -1026,9 +1007,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 					 case CHARS_PLAYER: 						 Player[CurrentPlayer].Hit_duration = f; 						 break;					 case CHARS_PLAYER2:						 Player2[CurrentPlayer].Hit_duration = f;						 break; 					 case CHARS_SHIP:						 						Navy.Ship[Navy.CurrentShip]->Hit_duration = f; 						break;					[36m@@ -1065,12 +1043,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 						 else	if (intAux == CP_INFINITE_LIVES) 								Player[CurrentPlayer].Health = Player[CurrentPlayer].MaxHealth = CP_INFINITE_LIVES; 						 break;					case CHARS_PLAYER2:						 if(intAux>0)								Player2[CurrentPlayer].Health = Player2[CurrentPlayer].MaxHealth = intAux;						 else	if (intAux == CP_INFINITE_LIVES)								Player2[CurrentPlayer].Health = Player2[CurrentPlayer].MaxHealth = CP_INFINITE_LIVES;						 break; 					 case CHARS_SHIP: 						 if(intAux > 0) 							 Navy.Ship[Navy.CurrentShip]->Health = Navy.Ship[Navy.CurrentShip]->MaxHealth = intAux;						 [36m@@ -1210,7 +1182,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 		break; 	case LIVES_L:		//Amount of ships the Player has still before finishing the game 			Player[CurrentPlayer].Lives = atoi(rText);			Player2[CurrentPlayer].Lives = atoi(rText); 		break; 	case MESH_CHARACTER_L: 			switch (CLeP_CharType)[36m@@ -1268,21 +1239,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 						strcpy(Player[CurrentPlayer].MeshName, defaultPlayer.MeshName); 					}			 					break;				case CHARS_PLAYER2:					strcpy(msj, rText);					if(strcmp(msj, defaultPlayer2.MeshName)){		//return 0 if strings are equal						MeshesManager.AddModel(msj);						Player2[CurrentPlayer].IndMesh	= MeshesManager.Meshes.size()-1;						Player2[CurrentPlayer].Mesh		= MeshesManager.Meshes[Player2[CurrentPlayer].IndMesh];						strcpy(Player2[CurrentPlayer].MeshName, Player2[CurrentPlayer].Mesh->GetFileName());					}					else					{						Player2[CurrentPlayer].IndMesh	= defaultPlayer2.IndMesh;						Player2[CurrentPlayer].Mesh		= defaultPlayer2.Mesh;						strcpy(Player2[CurrentPlayer].MeshName, defaultPlayer2.MeshName);					}								break; 				case CHARS_LASER: 					strcpy(msj, rText); 					if(strcmp(msj, defaultPlayer.Laser[CP_LEFT_LASER].MeshName))[36m@@ -1307,29 +1263,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 						Player[CurrentPlayer].Laser[CP_RIGHT_LASER].Mesh	= defaultPlayer.Laser[CP_LEFT_LASER].Mesh; 						strcpy(Player[CurrentPlayer].Laser[CP_RIGHT_LASER].MeshName, defaultPlayer.Laser[CP_LEFT_LASER].Mesh->GetFileName()); 					}					if(strcmp(msj, defaultPlayer2.Laser[CP_LEFT_LASER].MeshName))					{		//return 0 if strings are equal						MeshesManager.AddModel(msj);								Player2[CurrentPlayer].Laser[CP_LEFT_LASER].IndMesh	= MeshesManager.Meshes.size()-1;						Player2[CurrentPlayer].Laser[CP_LEFT_LASER].Mesh		= MeshesManager.Meshes[Player2[CurrentPlayer].Laser[CP_LEFT_LASER].IndMesh];						strcpy(Player2[CurrentPlayer].Laser[CP_LEFT_LASER].MeshName, Player2[CurrentPlayer].Laser[CP_LEFT_LASER].Mesh->GetFileName());										Player2[CurrentPlayer].Laser[CP_RIGHT_LASER].IndMesh = MeshesManager.Meshes.size()-1;						Player2[CurrentPlayer].Laser[CP_RIGHT_LASER].Mesh	= MeshesManager.Meshes[Player2[CurrentPlayer].Laser[CP_RIGHT_LASER].IndMesh];						strcpy(Player2[CurrentPlayer].Laser[CP_RIGHT_LASER].MeshName, Player2[CurrentPlayer].Laser[CP_RIGHT_LASER].Mesh->GetFileName());					}					else					{		//return 0 if strings are equal						MeshesManager.AddModel(msj);								Player2[CurrentPlayer].Laser[CP_LEFT_LASER].IndMesh	= defaultPlayer2.Laser[CP_LEFT_LASER].IndMesh;						Player2[CurrentPlayer].Laser[CP_LEFT_LASER].Mesh		= defaultPlayer2.Laser[CP_LEFT_LASER].Mesh;						strcpy(Player2[CurrentPlayer].Laser[CP_LEFT_LASER].MeshName, defaultPlayer2.Laser[CP_LEFT_LASER].Mesh->GetFileName());										Player2[CurrentPlayer].Laser[CP_RIGHT_LASER].IndMesh = defaultPlayer2.Laser[CP_LEFT_LASER].IndMesh;						Player2[CurrentPlayer].Laser[CP_RIGHT_LASER].Mesh	= defaultPlayer2.Laser[CP_LEFT_LASER].Mesh;						strcpy(Player2[CurrentPlayer].Laser[CP_RIGHT_LASER].MeshName, defaultPlayer2.Laser[CP_LEFT_LASER].Mesh->GetFileName());					} 				 					break; 				case CHARS_SPHERE_OGIVE:[36m@@ -1402,15 +1335,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 				CurrentPlayer			= CP_DEFAULT_PLAYER; 				Player[CurrentPlayer]	= defaultPlayer; 				break;			case CHARS_PLAYER2:				//The Players are be defined in Global definitions. If it is not defined, a new player has to be created here.			/*	CurrentPlayer++;	//The first time CurrentPlayer passes from CP_NO_PLAYER (-1) to player 0				if (CP_MAX_PLAYERS < CurrentPlayer) 					CurrentPlayer = CP_MAX_PLAYERS-1;	///There is a limit for the amount of simultaneous players 			*/				CurrentPlayer			= CP_DEFAULT_PLAYER;				Player2[CurrentPlayer]	= defaultPlayer2;				break; 			case CHARS_SHIP: 				//Ship = new CShip; 				//*Ship = defaultShip;[36m@@ -1457,7 +1381,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 			case CHARS_BRICK: 			case CHARS_BUNKER: 			case CHARS_PLAYER:			case CHARS_PLAYER2: 			case CHARS_SHIP: 			case CHARS_SUPPLYSHIP: 			case CHARS_CIRCLESHIP:[36m@@ -1501,7 +1424,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 			case CHARS_BRICK: 			case CHARS_BUNKER: 			case CHARS_PLAYER:			case CHARS_PLAYER2: 			case CHARS_SHIP: 			case CHARS_SUPPLYSHIP: 			case CHARS_CIRCLESHIP:[36m@@ -1596,13 +1518,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 					Player[CurrentPlayer].IndTexture2D = TexturesManager.Textures.size()-1; 				} 				 break;			case CHARS_PLAYER2:				strcpy(msj, rText);				if(strcmp(msj, TexturesManager.Textures[defaultPlayer2.IndTexture2D]->GetFileName())){					TexturesManager.CreateTexture(msj);					Player2[CurrentPlayer].IndTexture2D = TexturesManager.Textures.size()-1;				}				 break; 			case CHARS_SHIP: 				strcpy(msj, rText); 				if(strcmp(msj, TexturesManager.Textures[defaultShip.IndTexture2D]->GetFileName())){[36m@@ -1644,13 +1559,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 					AnimationsManager.Animations.back()->AddPhotogram(TexturesManager.Textures.back()); 				} 				 break;			case CHARS_PLAYER2:				strcpy(msj, rText);						if(!AnimationExist){					TexturesManager.CreateTexture(msj);					AnimationsManager.Animations.back()->AddPhotogram(TexturesManager.Textures.back());				}				 break; 			case CHARS_SHIP: 				if(!AnimationExist){ 					strcpy(msj, rText);[36m@@ -1692,13 +1600,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 					Player[CurrentPlayer].IndTexture3D = TexturesManager.Textures.size()-1; 				} 				 break;			case CHARS_PLAYER2:				strcpy(msj, rText);				if(strcmp(msj, TexturesManager.Textures[defaultPlayer2.IndTexture3D]->GetFileName())){					TexturesManager.CreateTexture(msj);					Player2[CurrentPlayer].IndTexture3D = TexturesManager.Textures.size()-1;				}				 break; 			case CHARS_SHIP: 				strcpy(msj, rText); 				if(strcmp(msj, TexturesManager.Textures[defaultShip.IndTexture3D]->GetFileName())){[36m@@ -1748,9 +1649,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 	case TIMEPLAYER_L: 		Game.PlayerTemp=atoi(rText); 		break;	case TIMEPLAYER2_L:		Game.Player2Temp=atoi(rText);		break; 	case TIMERENDER_L: 		Game.RenderTemp=atof(rText); 		break;[36m@@ -1799,7 +1697,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 			case CHARS_BRICK: 			case CHARS_BUNKER: 			case CHARS_PLAYER:			case CHARS_PLAYER2: 			case CHARS_SHIP: 			case CHARS_SUPPLYSHIP: 			case CHARS_CIRCLESHIP:[36m@@ -1856,9 +1753,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 				 case CHARS_PLAYER: 					 Player[CurrentPlayer].MoveTo(f, Player[CurrentPlayer].Position.v[YDIM], Player[CurrentPlayer].Position.v[ZDIM]); 					 break;				 case CHARS_PLAYER2:					 Player2[CurrentPlayer].MoveTo(f, Player2[CurrentPlayer].Position.v[YDIM], Player2[CurrentPlayer].Position.v[ZDIM]);					 break; 				 case CHARS_SUPPLYSHIP: 					 Navy.SupplyShip[Navy.CurrentSupplyShip]->MoveTo(f, Navy.SupplyShip[Navy.CurrentSupplyShip]->Position.v[YDIM], Navy.SupplyShip[Navy.CurrentSupplyShip]->Position.v[ZDIM]); 					 break;[36m@@ -1885,9 +1779,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 				 case CHARS_PLAYER: 					 Player[CurrentPlayer].Speed.v[XDIM] = f; 					 break;				 case CHARS_PLAYER2:					 Player2[CurrentPlayer].Speed.v[XDIM] = f;					 break; 				 case CHARS_SUPPLYSHIP: 					 Navy.SupplyShip[Navy.CurrentSupplyShip]->Speed.v[XDIM] = f; 					 break;[36m@@ -1933,9 +1824,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 				 case CHARS_PLAYER: 					 Player[CurrentPlayer].MoveTo(Player[CurrentPlayer].Position.v[XDIM], f, Player[CurrentPlayer].Position.v[ZDIM]); 					 break;				 case CHARS_PLAYER2:					 Player2[CurrentPlayer].MoveTo(Player2[CurrentPlayer].Position.v[XDIM], f, Player2[CurrentPlayer].Position.v[ZDIM]);					 break; 				 case CHARS_SUPPLYSHIP: 					 Navy.SupplyShip[Navy.CurrentSupplyShip]->MoveTo(Navy.SupplyShip[Navy.CurrentSupplyShip]->Position.v[XDIM], f, Navy.SupplyShip[Navy.CurrentSupplyShip]->Position.v[ZDIM]); 					 break;[36m@@ -1962,9 +1850,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 				 case CHARS_PLAYER: 					 Player[CurrentPlayer].Speed.v[YDIM] = f; 					 break;				 case CHARS_PLAYER2:					 Player2[CurrentPlayer].Speed.v[YDIM] = f;					 break; 				 case CHARS_SUPPLYSHIP:  					 Navy.SupplyShip[Navy.CurrentSupplyShip]->Speed.v[YDIM] = f; 					 break;[36m@@ -2010,9 +1895,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 				 case CHARS_PLAYER: 					 Player[CurrentPlayer].MoveTo(Player[CurrentPlayer].Position.v[XDIM], Player[CurrentPlayer].Position.v[YDIM], f); 					 break;				 case CHARS_PLAYER2:					 Player2[CurrentPlayer].MoveTo(Player2[CurrentPlayer].Position.v[XDIM], Player2[CurrentPlayer].Position.v[YDIM], f);					 break; 				 case CHARS_SUPPLYSHIP: 					 Navy.SupplyShip[Navy.CurrentSupplyShip]->MoveTo(Navy.SupplyShip[Navy.CurrentSupplyShip]->Position.v[XDIM], Navy.SupplyShip[Navy.CurrentSupplyShip]->Position.v[YDIM], f); 					 break;[36m@@ -2039,9 +1921,6 @@[m [mLogFile << CP_ParserMsgs[LOG_PARSER_TEXT] << rText << std::endl; 				 case CHARS_PLAYER: 					 Player[CurrentPlayer].Speed.v[ZDIM] = f; 					 break;				 case CHARS_PLAYER2:					 Player2[CurrentPlayer].Speed.v[ZDIM] = f;					 break; 				 case CHARS_SUPPLYSHIP: 					 Navy.SupplyShip[Navy.CurrentSupplyShip]->Speed.v[ZDIM] = f; 					 break;[1mdiff --git a/src/Main_SI_2013.cpp b/src/Main_SI_2013.cpp[1mindex ca7a853..f9d6d9f 100644[1m--- a/src/Main_SI_2013.cpp[1m+++ b/src/Main_SI_2013.cpp[36m@@ -64,23 +64,23 @@[m [mDWORD  SetUpHCI () 	HMENU hLoad		= CreateMenu(); 	HMENU hHelp		= CreateMenu(); 	HMENU idioma	= CreateMenu();	HMENU maxMinWin = CreateMenu(); 	AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hGame, LPCSTR("Game")); //"Space Invaders"	[AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hGame, LPCSTR(SIGLB_GetText(TR_MENU_WINDOW_SI))); //"Space Invaders" 	 	AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hLoad, LPCSTR("Load Level"));		AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hHelp, LPCSTR("Help"));	//"Help"	[AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)hHelp, LPCSTR(SIGLB_GetText(TR_MENU_WINDOW_HELP)));	//"Help"  	AppendMenu(hMenubar, MF_POPUP, (UINT_PTR)idioma, LPCSTR("Language"));	AppendMenu(hGame, MF_STRING, ID_Start, LPCSTR("Start game"));	//"Start Game"	AppendMenu(hGame, MF_STRING, ID_FULLSCREEN, LPCSTR("Max/Min Window"));	[AppendMenu(hGame, MF_STRING, ID_Start, LPCSTR(SIGLB_GetText(TR_FUNCTIONS_START_GAME)));	//"Start Game" 	AppendMenu(hGame, MF_STRING, ID_Exit, LPCSTR("Exit")); 	AppendMenu(idioma, MF_STRING, ID_LANGUAGE_FR, LPCSTR("French"));	//French	AppendMenu(idioma, MF_STRING, ID_LANGUAGE_ES, LPCSTR("Spanish"));	//Spanish	AppendMenu(idioma, MF_STRING, ID_LANGUAGE_EN, LPCSTR("English"));	//English	AppendMenu(idioma, MF_STRING, ID_LANGUAGE_CA, LPCSTR("Catalan"));	//Catalonian	[AppendMenu(idioma, MF_STRING, ID_LANGUAGE_FR, LPCSTR(SIGLB_GetText(TR_TAG_FRENCH)));	//French	[AppendMenu(idioma, MF_STRING, ID_LANGUAGE_ES, LPCSTR(SIGLB_GetText(TR_TAG_SPANISH)));	//Spanish	[AppendMenu(idioma, MF_STRING, ID_LANGUAGE_EN, LPCSTR(SIGLB_GetText(TR_TAG_ENGLISH)));	//English	[AppendMenu(idioma, MF_STRING, ID_LANGUAGE_CA, LPCSTR(SIGLB_GetText(TR_TAG_CATALAN)));	//Catalonian  	//Reading possible levels in .\Levels\UserLevels 	TCHAR szDir[MAX_PATH];[36m@@ -405,16 +405,6 @@[m [mLRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) 				GenerateFullLangName(DefaultLang, CA_DEFAULT_LANGUAGE_FILE); 				CopyFile(SourceLang.c_str(),DefaultLang.c_str(),FALSE);				   				break;			case ID_FULLSCREEN:									// Toggle FullScreen Mode On/Off				Application.Window.Visible = TRUE;									// Set Visible To True				Application.Window.Width	= GraphicsCard.DeskTop.Width;				Application.Window.Height	= GraphicsCard.DeskTop.Height;				Game.ReshapeGL();								break;			case ID_MINIMIZE:									// Toggle FullScreen Mode On/Off				Application.Window.Visible = FALSE;									// Set Visible To True				Game.ReshapeGL();								break;		 			} 		} 	case WM_PAINT:[1mdiff --git a/src/Player2.cpp b/src/Player2.cpp/*///////////////////////////////////////////////////////////////////////////////////////// Player initialization or constructor//// These values are by default. They have to be overwritten in the initializatio phase// when reading the default values from the "initialization.html" file	@author Ramon Molla	@version 2011-09-11	*/#include "Global.h"#include "Player2.h"#include <math.h>#include <gl.h>#include <glext.h>#include "Bonus.h"//Vector CP_REACTOR_REL_POS;bool CPlayer2::Init ()	//Used when all the values are initialized by default						//when reading the global initialization game file. 						//Returns true if the initialization of the attirbute has been correctly done{	Type			=	CHARS_PLAYER2;	Lives			=	CP_DEFAULT_LIVES;	Health			=	MaxHealth = CP_MAX_HEALTH;	Hit_duration	=	CP_MAX_MAX_HIT_DUR;#ifdef CHAR_USE_AABB	InitializeAABB();#endif	MoveTo(0.0f, -6.15f, 0.05f);	///This updates the AABB	yi				=	0.00;	yi_speed		=	0.01f;	yi_cos			=	0;	zi				=	0.00;	zi_speed		=	0.01f;	Size.v[XDIM]					= 0.6f;	Size.v[YDIM]					= 0.4f;	Speed.Reset();	Acceleration.Reset();	Speed.v[XDIM]		= CP_MAX_SPEED;	Acceleration.v[XDIM] = CP_MAX_ACCEL;	Alive = true;	ShootType		=	CSH_PLAYER;	RenderMode = CHAR_2D;	ActivateReactor();	return true;}////////////////////////////////////////////////////////////////////////////////////////// Player Initialisation ////CPlayer2::CPlayer2(){	Init();	msg = new RTDESK_CMsg;	msg->Type = RTDESKMSG_BASIC_TYPE;	msg->Propietary = true;}//AIvoid CPlayer2::AI_Init	(void)	///Default Artificial Intelligence character initialization{	State = CP_UNBORN;}void CPlayer2::AI_Dye (void){		Active = Alive  = false;}void CPlayer2::AI_Explode (void){	SoundsManager.Play(CGS_TOUCH,UGKSND_ULTRA_LOW_VOLUME);		Explosion.Init(this);	Explosion.Active=true;}	void CPlayer2::ActivateReactor(){	Reactor.Alive = Reactor.Active = true;	Reactor.Position = Position;}void CPlayer2::ActivateLaser(CP_PLAYER_LASER LaserActivated){	Laser[LaserActivated].Alive = Laser[LaserActivated].Active = true;	Laser[LaserActivated].Explosion.Alive = false;		if (CP_LEFT_LASER == LaserActivated)		Laser[LaserActivated].Position.v[XDIM] = Position.v[XDIM] - Size.v[XDIM] - CP_LASER_REL_POS;	else 		Laser[LaserActivated].Position.v[XDIM] = Position.v[XDIM] + Size.v[XDIM] + CP_LASER_REL_POS;	Laser[LaserActivated].Position.v[YDIM] = Position.v[YDIM];	Laser[LaserActivated].Position.v[ZDIM] = Position.v[ZDIM];	QuadtreeRoot::Instance()->getQuadtree()->ActualizeCharacter(&Laser[LaserActivated]);}//Physicsvoid CPlayer2::Collided (CCharacter *CollidedChar){	switch (CollidedChar->Type)	{	case CHARS_SHIP:	case CHARS_MISSIL:		if (Alive && !Immortal && ((CShoot*)CollidedChar)->SubType!=CSH_PLAYER)		{			#ifdef DEBUG_MORTAL			if (CSIG_PASSING_2_3D == Game.AI->GetState())	return;	// Stop checking more collisions. The player is protected while changing from mode 2D to mode 3D						SoundsManager.Play(CGS_TOUCH,UGKSND_VOLUME_60);			SoundsManager.SetPosition(CGS_TOUCH,NULL);			if(CHAR_2D == RenderMode)				Health  = 0;			else				Health -= CollidedChar->Health;			Hit_duration--;			if (Health <= 0)			{							//... and everything has to explode, if exists				if (Laser[CP_LEFT_LASER].Alive)					Laser[CP_LEFT_LASER].AI_Explode();				if (Laser[CP_RIGHT_LASER].Alive)					Laser[CP_RIGHT_LASER].AI_Explode();								SoundsManager.Play(CGS_EXPLOSION,UGKSND_VOLUME_80);				Explosion.Init();				Explosion.Active=true;				AI_Dye();				//Player loses its life...				Game.GameEvent(CSIG_LIFE_LOST);	//v Controlado 4->7			}			#endif		}		break;	case CHARS_BONUS:		//These collisions are detected and managed by bonus manager when collided with the player.		break;	}}void CPlayer2::ChangeRenderMode(CHAR_RENDER_MODE Mode){	RenderMode = Mode;	Explosion.ChangeRenderMode(Mode);	Reactor.ChangeRenderMode(Mode);	switch(RenderMode)	{	case CHAR_NO_RENDER:			//No render for this character: camera, collision objects,...		return;	case CHAR_2D:		Position.v[YDIM]			= CSIG_PLAYER_Y_POSITION;		ShootType					= CSH_PLAYER;		ShootSpeed					= CP_SHOOT2D_SPEED;		//No laser support when in 2D mode		Laser[CP_LEFT_LASER].Alive	= false;		Laser[CP_RIGHT_LASER].Alive	= false;		Laser[CP_LEFT_LASER].Active	= false;		Laser[CP_RIGHT_LASER].Active= false;		Reactor.Active = Reactor.Alive = false;		Size.v[XDIM]					= CP_2D_SIZE_X;		Size.v[YDIM]					= CP_2D_SIZE_Y;		Speed.v[XDIM]				= CP_MAX_SPEED;	//There is no acceleration. Instant max speed when moving		break;	case CHAR_LINES3D:	case CHAR_3D:		//Position.v[YDIM]	= CSIG_PLAYER_Y_POSITION -.5f;		MoveTo(Position.v[XDIM], CSIG_PLAYER_Y_POSITION -.5f, Position.v[ZDIM]);		ShootType		= CSH_PLAYER3D;		ShootSpeed		= CP_SHOOT3D_SPEED;		Size.v[XDIM]		=	CP_3D_SIZE_X - Mesh->modelo.rot.z/250; // Mesh->rot.v[ZDIM] (de -48.xx ? 48.xx) correspond au penchement du joueur donc sa taille projet?e en 2D est plus faible (la gestion de collision est en 2D)		Size.v[YDIM]		=	CP_3D_SIZE_Y;		if(Mesh)			if(Mesh->Loaded)				FitMeshIntoBoundingBox(*Mesh);		Laser[CP_LEFT_LASER].Size.v[XDIM] = Size.v[XDIM]/3;		Laser[CP_LEFT_LASER].Size.v[YDIM] = Size.v[YDIM];		Laser[CP_RIGHT_LASER].Size.v[XDIM] = Size.v[XDIM]/3;		Laser[CP_RIGHT_LASER].Size.v[YDIM] = Size.v[YDIM];		if(Laser[CP_LEFT_LASER].Mesh)			if(Laser[CP_LEFT_LASER].Mesh->Loaded)				Laser[CP_LEFT_LASER].FitMeshIntoBoundingBox(*Laser[CP_LEFT_LASER].Mesh);		if(Laser[CP_RIGHT_LASER].Mesh)			if(Laser[CP_RIGHT_LASER].Mesh->Loaded)				Laser[CP_RIGHT_LASER].FitMeshIntoBoundingBox(*Laser[CP_RIGHT_LASER].Mesh);		ActivateReactor();		break;	default: return;	}	Size.v[ZDIM]		=	0.0f;#ifdef CHAR_USE_AABB	UpdateAABB();#endif}void CPlayer2::Render(void){	// GAME 2D	if (CHAR_2D == RenderMode)	{		glColor4f (1.0f, 1.0f, 1.0f, 1.0f);		TexturesManager.Textures[IndTexture2D]->SetTexture();		// ALPHA TEST + BLEND		glAlphaFunc(GL_GREATER, 0.3f);								// for TGA alpha test		glEnable(GL_ALPHA_TEST);									// for TGA alpha test		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);			// for anti-aliasing		glBegin (GL_QUADS);			glTexCoord2f (0,1);	glVertex2f (Position.v[XDIM] - Size.v[XDIM]/2.f, Position.v[YDIM] + Size.v[YDIM]/2.f);			glTexCoord2f (0,0);	glVertex2f (Position.v[XDIM] - Size.v[XDIM]/2.f, Position.v[YDIM] - Size.v[YDIM]/2.f);			glTexCoord2f (1,0);	glVertex2f (Position.v[XDIM] + Size.v[XDIM]/2.f, Position.v[YDIM] - Size.v[YDIM]/2.f);			glTexCoord2f (1,1);	glVertex2f (Position.v[XDIM] + Size.v[XDIM]/2.f, Position.v[YDIM] + Size.v[YDIM]/2.f);		glEnd ();		// BACK TO NON ALPHA TEST + PREVIOUS BLEND		glDisable(GL_ALPHA_TEST);		glBlendFunc(GL_SRC_ALPHA,GL_ONE);	}	else	// GAME 3D	{		// Player		Mesh->modelo.rot.x =  -270.0f;		Mesh->modelo.scaleY = 0.15f;		Mesh->modelo.pos.x = Position.v[XDIM];		if (CSIG_PASSING_2_3D != Game.AI->GetState())			Mesh->modelo.pos.y = Position.v[YDIM];		//Control to rotate Player		Mesh->modelo.rot.z = -Scrolling * 11000;		if(Mesh->modelo.rot.z > 50) Mesh->modelo.rot.z = 50;		else if(Mesh->modelo.rot.z < -50) Mesh->modelo.rot.z = -50;  //[-50, 50]		// Anti-aliasing (DEBUT)		if (Application.Window.Antialiasing_active && CHAR_3D == RenderMode)			glEnable(GL_MULTISAMPLE_ARB);		// Player touched		if (Hit_duration < 500)		{			Hit_duration -= 20 * Game.RenderTemp;			if (Hit_duration <= 0)				Hit_duration = 500;			Mesh->modelo.Draw();	// vaisseau non textur?, blanc		}				// Normal player drawing		else			Mesh->modelo.Draw();		// Anti-aliasing		if (Application.Window.Antialiasing_active && CHAR_3D == RenderMode)		glDisable(GL_MULTISAMPLE_ARB);		if(Laser[CP_LEFT_LASER].Alive) Laser[CP_LEFT_LASER].Render();		if(Laser[CP_RIGHT_LASER].Alive)Laser[CP_RIGHT_LASER].Render();		//In 2D, no reactor has to be rendered		if(CHAR_2D != RenderMode && Reactor.Active) Reactor.Render();				}	}///Geometric transformation methodsvoid CPlayer2::MoveTo		(float x, float y, float z)	///Moves to the absolute coordinate x,y,z{	Vector P;	P.Set(x, y, z);	MoveTo(P);}void CPlayer2::MoveTo		(Vector &Move)				///Moving to an absolute position. It does not matter where the character is{	Position = Move; #ifdef CHAR_USE_AABB	///Updating the bounding box	UpdateAABB ();#endif		//Left Laser position update	if (Laser[CP_LEFT_LASER].Active){		Laser[CP_LEFT_LASER].Position = Position;		Laser[CP_LEFT_LASER].Position.v[XDIM] = Position.v[XDIM] - Size.v[XDIM] - CP_LASER_REL_POS;		QuadtreeRoot::Instance()->getQuadtree()->ActualizeCharacter(&Laser[CP_LEFT_LASER]);	}	//Right Laser position update	if (Laser[CP_RIGHT_LASER].Active){		Laser[CP_RIGHT_LASER].Position = Position;		Laser[CP_RIGHT_LASER].Position.v[XDIM] = Position.v[XDIM] + Size.v[XDIM] + CP_LASER_REL_POS;		QuadtreeRoot::Instance()->getQuadtree()->ActualizeCharacter(&Laser[CP_RIGHT_LASER]);	}		Reactor.Position = Position;}void CPlayer2::MoveRelTo	(float x, float y, float z)	///Moves x,y,z units from the to the current position{	Vector P;	P.Set(x, y, z);	MoveRelTo(P);}void CPlayer2::MoveRelTo (Vector &Move)	///Moving relative to the character current Position{	///Adding relative movement	Position						+= Move;#ifdef CHAR_USE_AABB	///Updating the bounding box	UpdateAABB ();#endif	if (Laser[CP_LEFT_LASER].Active){		Laser[CP_LEFT_LASER].Position = Position;		Laser[CP_LEFT_LASER].Position.v[XDIM] = Position.v[XDIM] - Size.v[XDIM] - CP_LASER_REL_POS;		QuadtreeRoot::Instance()->getQuadtree()->ActualizeCharacter(&Laser[CP_LEFT_LASER]);	}			if (Laser[CP_RIGHT_LASER].Active){		Laser[CP_RIGHT_LASER].Position = Position;		Laser[CP_RIGHT_LASER].Position.v[XDIM] = Position.v[XDIM] + Size.v[XDIM] + CP_LASER_REL_POS;		QuadtreeRoot::Instance()->getQuadtree()->ActualizeCharacter(&Laser[CP_RIGHT_LASER]);	}	Reactor.Position = Position;}	//User interaction. One method for every player command sent to the player's avatarvoid CPlayer2::ManageEvent	(unsigned int Event){		switch (Event)		{		case CP_MOVE_LEFT:			///The player wants to move to the left			UserLeft();			break;		case CP_MOVE_RIGHT:			///The player wants to move to the right			UserRight();			break;		case CP_SHOOT:				///The player wants to fire a shoot			if(!DiscreteSimulation) UserShoot();			else DiscreteUserShoot();			break;		}}void CPlayer2::UserRight	(){	PositionPrev=Position;	if (Alive)	{		//ACHTUNG: To do		/*if (CHAR_3D == RenderMode)		{			Speed.v[XDIM] += Acceleration.v[XDIM] * msUpdPlayer;			if (Speed.v[XDIM] > CP_MAX_SPEED)				Speed.v[XDIM] = CP_MAX_SPEED;			MoveRelTo(Speed.v[XDIM]*msUpdPlayer, 0.0f, 0.0f);		}		else*/ 			MoveRelTo(Speed.v[XDIM]*msUpdPlayer, 0.0f, 0.0f);	///Speed is constant (in 2D mode		if (Position.v[XDIM] > CSIG_PG_RIGHT)			Position.v[XDIM] = CSIG_PG_RIGHT;		//Control to rotate the Player		Scrolling = Speed.v[XDIM];	}	QuadtreeRoot::Instance()->getQuadtree()->ActualizeCharacter(this);}void CPlayer2::UserLeft	(){	PositionPrev=Position;	if (Alive)	{		//ACHTUNG: To do		/*if (CHAR_3D == RenderMode)						{			Speed.v[XDIM] -= Acceleration.v[XDIM] * msUpdPlayer;			if (Speed.v[XDIM] < - CP_MAX_SPEED)				Speed.v[XDIM] = - CP_MAX_SPEED;			MoveRelTo(Speed.v[XDIM]*msUpdPlayer,  0.0f, 0.0f);		}		else */			MoveRelTo(-Speed.v[XDIM]*msUpdPlayer,  0.0f, 0.0f); ///Speed is constant in 2D mode		if (Position.v[XDIM] < CSIG_PG_LEFT)			Position.v[XDIM] = CSIG_PG_LEFT;		//Control to rotate the Player		Scrolling = -Speed.v[XDIM];	}			QuadtreeRoot::Instance()->getQuadtree()->ActualizeCharacter(this);}void CPlayer2::Update(void){	#ifdef DEF_UPD_TIME	Game.TimerManager.Timers[TmrUpd].InitCounting();	#endif	RTDESK_TIME nowTime, elapTime;	nowTime = Game.TimerManager.Timers[TmrApp].TicksUntilNow();	elapTime = nowTime - LastUpdTime;	if(elapTime >= TicksToUpdatePlayer){#ifndef DEF_CONTINUOUS_WITH_SIMULATE_TIME		LastUpdTime = nowTime;		msUpdPlayer = abs(Size.v[YDIM]/Speed.v[YDIM]);		if(msUpdPlayer > CSIG_MIN_UPDATETIME_OBJECTS) msUpdPlayer = CSIG_MIN_UPDATETIME_OBJECTS;		TicksToUpdatePlayer = UpdatePlayerTimer.ms2Ticks(msUpdPlayer);		//Control to rotate the Player		if(Scrolling >  0.0001) Scrolling -= 0.001;		if(Scrolling < -0.0001) Scrolling += 0.001;#else		bool SynWithRealTime = false;		LastUpdTime += TicksToUpdatePlayer;		msUpdPlayer = abs(Size.v[YDIM]/Speed.v[YDIM]);		if(msUpdPlayer > CSIG_MIN_UPDATETIME_OBJECTS) msUpdPlayer = CSIG_MIN_UPDATETIME_OBJECTS;		TicksToUpdatePlayer = UpdatePlayerTimer.ms2Ticks(msUpdPlayer);		while(!SynWithRealTime){			//Control to rotate the Player			if(Scrolling >  0.0001) Scrolling -= 0.001;			if(Scrolling < -0.0001) Scrolling += 0.001;		nowTime = Game.TimerManager.Timers[TmrApp].TicksUntilNow();		elapTime = nowTime - LastUpdTime;		if(elapTime >= 0LL) 				SynWithRealTime=true;			else				SynWithRealTime=false;		}#endif	}	#ifdef DEF_UPD_TIME	EndAccCounting(TmrUpd);	#endif}void CPlayer2::DiscreteUpdate(void){	#ifdef DEF_UPD_TIME	Game.TimerManager.Timers[TmrUpd].InitCounting();	#endif	//Control to rotate the Player	if(Scrolling >  0.0001) Scrolling -= 0.001;	if(Scrolling < -0.0001) Scrolling += 0.001;	msUpdPlayer = abs(Size.v[YDIM]/Speed.v[YDIM]);	if(msUpdPlayer > CSIG_MIN_UPDATETIME_OBJECTS) msUpdPlayer = CSIG_MIN_UPDATETIME_OBJECTS;	TicksToUpdatePlayer = UpdatePlayerTimer.ms2Ticks(msUpdPlayer);	#ifdef DEF_UPD_TIME	EndAccCounting(TmrUpd);	#endif	if(!endByTime && !endByFrame){		#ifdef DEF_RTD_TIME		Game.TimerManager.Timers[TmrRTDSKMM].InitCounting();		#endif		SendSelfMsg(msg,TicksToUpdatePlayer);		#ifdef DEF_RTD_TIME		EndAccCounting(TmrRTDSKMM);		#endif	}}void CPlayer2::ReceiveMessage(RTDESK_CMsg *pMsg){			DiscreteUpdate();}void CPlayer2::UserShoot	(){	Vector	P,	//Shoot initial Position			S;	//Shoot initial Speed	if (Alive != true) return;	///No gun is fired when the player is dead		if (CHAR_2D == RenderMode)		{			SoundsManager.Play(CGS_SHOOT,UGKSND_LOW_VOLUME);			S.v[XDIM] = S.v[ZDIM] = 0.0f;			S.v[YDIM] = CP_SHOOT2D_SPEED;		}		else		{			SoundsManager.Play(CGS_SHOOT3D,UGKSND_LOW_VOLUME);						S.v[XDIM] = S.v[ZDIM] = 0.0f;			S.v[YDIM] = CP_SHOOT3D_SPEED;		}		///Generate a new player fire		//x					if (CHAR_2D == RenderMode){			P.v[XDIM]	= Position.v[XDIM];			P.v[YDIM]	= Position.v[YDIM] + .5f;			P.v[ZDIM]	= Position.v[ZDIM];		}		else{			P.v[XDIM]	= Position.v[XDIM];			P.v[YDIM]	= Position.v[YDIM] + 1.5f;			P.v[ZDIM]	= Mesh->modelo.pos.z;		}					ShootsManager.NewShoot(Player2[CurrentPlayer].ShootType, P, S);				//Auxiliar shoots with Bonus Weapon		if(Player2[CurrentPlayer].ShootType == CSH_PLAYER3D_CHEVRON){			P.v[XDIM] += 0.5;			ShootsManager.nextShootVisible = true;			ShootsManager.NewShoot(Player2[CurrentPlayer].ShootType, P, S);			P.v[XDIM] -= 0.5;			P.v[XDIM] -= 0.5;			ShootsManager.nextShootVisible = true;			ShootsManager.NewShoot(Player2[CurrentPlayer].ShootType, P, S);		}		if (Player2[CurrentPlayer].Laser[CP_LEFT_LASER].Alive)						//Left Laser shoot		{			P.v[XDIM]		= Position.v[XDIM] - .9f;			P.v[YDIM]		= Position.v[YDIM] + .8f;			P.v[ZDIM]		= Mesh->modelo.pos.z;			S.v[XDIM] = S.v[ZDIM] = 0.0f;			S.v[YDIM] = CP_SHOOT3D_SPEED;			ShootsManager.NewShoot(CSH_AUXILIAR_LASER, P, S);		}		if (Player2[CurrentPlayer].Laser[CP_RIGHT_LASER].Alive)						//Right Laser shoot		{			P.v[XDIM]		= Position.v[XDIM] + .9f;			P.v[YDIM]		= Position.v[YDIM] + .8f;			P.v[ZDIM]		= Mesh->modelo.pos.z;			S.v[XDIM] = S.v[ZDIM] = 0.0f;			S.v[YDIM] = CP_SHOOT3D_SPEED;			ShootsManager.NewShoot(CSH_AUXILIAR_LASER, P, S);		}}void CPlayer2::DiscreteUserShoot	(){	Vector	P,	//Shoot initial Position			S;	//Shoot initial Speed	if (Alive != true) return;	///No gun is fired when the player is dead		if (CHAR_2D == RenderMode)		{			SoundsManager.Play(CGS_SHOOT,UGKSND_LOW_VOLUME);			S.v[XDIM] = S.v[ZDIM] = 0.0f;			S.v[YDIM] = CP_SHOOT2D_SPEED;		}		else		{			SoundsManager.Play(CGS_SHOOT3D,UGKSND_LOW_VOLUME);						S.v[XDIM] = S.v[ZDIM] = 0.0f;			S.v[YDIM] = CP_SHOOT3D_SPEED;		}		///Generate a new player fire		//x					if (CHAR_2D == RenderMode){			P.v[XDIM]	= Position.v[XDIM];			P.v[YDIM]	= Position.v[YDIM] + .5f;			P.v[ZDIM]	= Position.v[ZDIM];		}		else{			P.v[XDIM]	= Position.v[XDIM];			P.v[YDIM]	= Position.v[YDIM] + 1.5f;			P.v[ZDIM]	= Mesh->modelo.pos.z;		}					DiscreteShootsManager.DiscreteNewShoot(Player2[CurrentPlayer].ShootType, P, S);		if(Player2[CurrentPlayer].ShootType == CSH_PLAYER3D_CHEVRON){			P.v[XDIM] += 0.5;			DiscreteShootsManager.nextShootVisible = true;			DiscreteShootsManager.DiscreteNewShoot(Player2[CurrentPlayer].ShootType, P, S);			P.v[XDIM] -= 0.5;			P.v[XDIM] -= 0.5;			DiscreteShootsManager.nextShootVisible = true;			DiscreteShootsManager.DiscreteNewShoot(Player2[CurrentPlayer].ShootType, P, S);		}		if (Player2[CurrentPlayer].Laser[CP_LEFT_LASER].Alive)						// le laser de gauche tire		{			P.v[XDIM]		= Position.v[XDIM] - .9f;			P.v[YDIM]		= Position.v[YDIM] + .8f;			P.v[ZDIM]		= Mesh->modelo.pos.z;			S.v[XDIM] = S.v[ZDIM] = 0.0f;			S.v[YDIM] = CP_SHOOT3D_SPEED;			DiscreteShootsManager.DiscreteNewShoot(CSH_AUXILIAR_LASER, P, S);		}		if (Player2[CurrentPlayer].Laser[CP_RIGHT_LASER].Alive)						// le laser de droite tire		{			P.v[XDIM]		= Position.v[XDIM] + .9f;			P.v[YDIM]		= Position.v[YDIM] + .8f;			P.v[ZDIM]		= Mesh->modelo.pos.z;			S.v[XDIM] = S.v[ZDIM] = 0.0f;			S.v[YDIM] = CP_SHOOT3D_SPEED;			DiscreteShootsManager.DiscreteNewShoot(CSH_AUXILIAR_LASER, P, S);		}}[1mdiff --git a/src/SIGame.cpp b/src/SIGame.cpp 	ShipTemp		=	41.0; 	NavyShipsTemp	=	41.0; 	PlayerTemp		=	41.0;	Player2Temp		=	41.0; 	ShootsTemp		=	41.0; 	RenderTemp		=	41.0; 	UpdateTemp		=	41.0;[36m@@ -253,7 +252,6 @@[m [mvoid CSIGame::Init(void) 	lastTimeSShipsUpd	= RTDESKT_NOTIME; 	lastTimeCShipsUpd	= RTDESKT_NOTIME; 	lastTimePlayerUpd	= RTDESKT_NOTIME;	lastTimePlayer2Upd	= RTDESKT_NOTIME; }  [36m@@ -516,7 +514,6 @@[m [mvoid CSIGame::Render(void)  	unsigned int i; 	static float position_player[] =		{-10.0, 20.0, 1.0, 0.0}; // for Player	static float position_player2[] =		{-10.0, 20.0, 1.0, 0.0}; // for Player2 	static float position_ships[]  =		{-10.0, 10.0, 5.0, 0.0}; // for ships 	static float position_ships2[] =		{ 10.0, 0.0, -20.0, 0.0};// for ships [36m@@ -557,9 +554,8 @@[m [mvoid CSIGame::Render(void)  		// LUMIERES -> POSITION 		glLightfv(GL_LIGHT0, GL_POSITION, position_player);		glLightfv(GL_LIGHT1, GL_POSITION, position_player2);		glLightfv(GL_LIGHT2, GL_POSITION, position_ships);		glLightfv(GL_LIGHT3, GL_POSITION, position_ships2);		[glLightfv(GL_LIGHT1, GL_POSITION, position_ships);		[glLightfv(GL_LIGHT2, GL_POSITION, position_ships2);  		 		// Background	[36m@@ -695,11 +691,6 @@[m [mvoid CSIGame::Render(void) 			if(Player[i].Alive) 				Player[i].Render();	 		//Players.		//for(i=0;i<CP_MAX_PLAYERS;i++)			if(Player2[0].Alive)				Player2[0].Render();	 		// LUMIERE DES SHIPS (DEBUT) ET PLAYER (FIN) 		if (CHAR_2D != Game.RenderMode) 		{[36m@@ -814,9 +805,6 @@[m [mvoid CSIGame::ChangeRenderMode(CHAR_RENDER_MODE Mode) 	//Players 	for(i=0;i<CP_MAX_PLAYERS;i++)	Player[i].ChangeRenderMode(RenderMode); 	//Players	for(i=0;i<CP_MAX_PLAYERS;i++)	Player2[i].ChangeRenderMode(RenderMode); 	//Bonus 	BonusManager.ChangeRenderMode(RenderMode); 	DiscreteBonusManager.ChangeRenderMode(RenderMode);[36m@@ -1221,8 +1209,6 @@[m [mbool CSIGame::Initialize (void) 	for(i=0;i<CP_MAX_PLAYERS;i++) 		Player[i] = defaultPlayer; 	for(i=0;i<CP_MAX_PLAYERS;i++)		Player2[i] = defaultPlayer2; 	StartAnimations();  	//Creates a thread in order to speed up the loading of the sounds[36m@@ -1396,11 +1382,6 @@[m [mvoid CSIGame::InitCharFactory() 	Character.Name	= CHARS_Tags[CHARS_PLAYER]; 	Character.Size	= sizeof(CPlayer); 	CharacterFactory.SetCharacter(Character);		Character.Id	= CHARS_PLAYER2;			///<The player2	Character.Name	= CHARS_Tags[CHARS_PLAYER2];	Character.Size	= sizeof(CPlayer2);	CharacterFactory.SetCharacter(Character);  	Character.Id	= CHARS_PLAYER_SHOOT;		///<Player shoots 	Character.Name	= CHARS_Tags[CHARS_PLAYER_SHOOT];[36m@@ -1840,8 +1821,6 @@[m [mvoid CSIGame::RunMainLoop(){ 				//Player Update 				Player[CurrentPlayer].Update(); 				//Player2 Update				Player2[CurrentPlayer].Update(); 				#ifdef DEF_IDL_TIME 				TimerManager.Timers[TmrIdl].InitCounting(); 				#endif[1mdiff --git a/src/SIKeyboard.cpp b/src/SIKeyboard.cppIK_ActionsDelay	[CSIK_MAX_KBD_ACTION] = { 	200,	//CSIK_TEXT2D  	1000,	//CSIK_PLAYER_PAUSE	200,		//CSIK_HELP	0,		//CSIK_PLAYER2_MOVE_RIGHT	Player2 ship is move rightwards	0,		//CSIK_PLAYER2_MOVE_LEFT		Player2 ship is move leftwards	200,	//CSIK_PLAYER2_SHOOT			Laser fire. 10 shoots per second	[200		//CSIK_HELP }; [36m@@ -63,7 +59,7 @@[m [mfloat	CSIK_ActionsDelay	[CSIK_MAX_KBD_ACTION] = { 	 [ESC]                 -> Game Quit 	 [+], [-]              -> Zoom in/out respectively TODO 	 [SPACE]               -> Change music 	 [F1]                  -> Change gaame from 2D to 3D and viceversa41m [m	[ [F1]                  -> Change game from 2D to 3D and viceversa 	 [A]                   -> Anti-aliasing on/off 	 [B]                   -> Change background 	 [L]                   -> Change Level of playing[36m@@ -112,10 +108,7 @@[m [munsigned char	CSIK_ActionKeys	[CSIK_MAX_KBD_ACTION] = { 	'T',		//CSIK_TEXT2D  	'P',		//CSIK_PLAYER_PAUSE	'H',			//CSIK_HELP	'I',		//Plyaer 2 right	'Y',		//player2 left	'7'			//player2 shoot	['H'			//CSIK_HELP }; [36m@@ -148,28 +141,6 @@[m [mvoid CSIKeyboard::Update ()	///<Release a new key from the active list of key pr 				Player[CurrentPlayer].ManageEvent(CP_MOVE_RIGHT); 			} 			break;		case CSIK_PLAYER2_SHOOT:			if (HRTimerManager.Timers[CSIK_PLAYER2_SHOOT].IsSounding())			{				HRTimerManager.Timers[CSIK_PLAYER2_SHOOT].ResetAlarm();				Player2[CurrentPlayer].ManageEvent(CP_SHOOT);			}			break;		case CSIK_PLAYER2_MOVE_LEFT:			if (HRTimerManager.Timers[CSIK_PLAYER2_MOVE_LEFT].IsSounding())			{				HRTimerManager.Timers[CSIK_PLAYER2_MOVE_LEFT].ResetAlarm();				Player2[CurrentPlayer].ManageEvent(CP_MOVE_LEFT);			}			break;		case CSIK_PLAYER2_MOVE_RIGHT:			if (HRTimerManager.Timers[CSIK_PLAYER2_MOVE_RIGHT].IsSounding())			{				HRTimerManager.Timers[CSIK_PLAYER2_MOVE_RIGHT].ResetAlarm();				Player2[CurrentPlayer].ManageEvent(CP_MOVE_RIGHT);			}			break; 		case CSIK_GAME_END: 			Game.GameEvent(CSIG_FADING2END);		//v Controlado 4->12 			break;